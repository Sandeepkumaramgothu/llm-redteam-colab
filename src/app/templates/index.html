<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Red Team — Day 8 (Generation Controls)</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 2rem; }
    a { color: #1a73e8; text-decoration: none; }
    a:hover { text-decoration: underline; }
    button { padding: 0.6rem 1rem; margin-right: 8px; }
    .bar { width: 420px; height: 12px; background: #eee; border-radius: 6px; overflow: hidden; margin: 10px 0; }
    .fill { height: 100%; background: #4a90e2; width: 0%; transition: width 0.2s; }
    .muted { color: #666; font-size: 0.95rem; }
    .ok { color: #0a0; }
    .err { color: #a00; }
    .mono { font-family: ui-monospace, Menlo, Consolas, monospace; white-space: pre-wrap; }
    .box { padding:10px; border:1px solid #eee; border-radius:8px; background:#fafafa; margin: 10px 0; }
    label { margin-right: 10px; }
  </style>
</head>
<body>
  <h2>Red Team — Day 8</h2>
  <p><a href="report">Open latest report →</a> (Preview shows <b>ALL</b> items)</p>

  <button id="start">Start</button>
  <button id="export">Export Report</button>
  <button id="zip">Zip Run</button>
  <button id="stop">Stop</button>

  <div class="box">
    <h3>Seeds</h3>
    <label>Source:
      <select id="seed_source">
        <option value="local" selected>Local (src/storage/seeds.json or seeds.jsonl)</option>
        <option value="dna">Hugging Face: Do-Not-Answer</option>
      </select>
    </label>
    <label>Count:
      <input id="seed_count" type="number" placeholder="(auto for local: ALL rows)" style="width:160px" />
    </label>
    <label>HF dataset id:
      <input id="hf_id" type="text" value="LibrAI/do-not-answer" style="width:260px" />
    </label>
    <div class="muted">Tip: With <b>Local</b>, leave <b>Count</b> blank to use ALL rows.</div>
  </div>

  <div class="box">
    <h3>Generation Controls (new!)</h3>
    <label>Temperature (0.0 to 1.0):
      <input id="temperature" type="number" step="0.1" min="0" max="1" value="0.7" style="width:80px" />
    </label>
    <label>Max new tokens (1 to 512):
      <input id="max_new_tokens" type="number" min="1" max="512" value="64" style="width:100px" />
    </label>
    <div class="muted">Lower temperature = safer/stricter; higher = more creative.</div>
  </div>

  <div class="bar"><div id="fill" class="fill"></div></div>
  <div id="phase" class="muted">phase: idle</div>
  <div id="iter" class="muted">iter: 0</div>
  <div id="done" class="muted"></div>
  <pre id="result" class="muted mono"></pre>

  <script>
    // Turn a relative path into a full URL in Colab.
    function toProxy(relPath) {
      if (!relPath) return window.location.href;
      if (relPath.startsWith("/")) relPath = relPath.slice(1);
      return new URL(relPath, window.location.href).href;
    }
    // GET JSON helper (errors if content-type is not JSON).
    async function getJSON(url) {
      const r = await fetch(toProxy(url));
      const ct = r.headers.get("content-type") || "";
      const txt = await r.text();
      if (!ct.includes("application/json")) throw new Error(`HTTP ${r.status} ${ct} :: ${txt.slice(0,160)}`);
      const data = JSON.parse(txt);
      if (!r.ok || data.ok === false) throw new Error((data && data.error) || `HTTP ${r.status}`);
      return data;
    }
    // POST JSON helper (same strictness).
    async function postJSON(url, body) {
      const r = await fetch(toProxy(url), { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body||{}) });
      const ct = r.headers.get("content-type") || "";
      const txt = await r.text();
      if (!ct.includes("application/json")) throw new Error(`HTTP ${r.status} ${ct} :: ${txt.slice(0,160)}`);
      const data = JSON.parse(txt);
      if (!r.ok || data.ok === false) throw new Error((data && data.error) || `HTTP ${r.status}`);
      return data;
    }
    // Download any relative path as a file using a Blob.
    async function blobDownload(relPath, filename) {
      const res = await fetch(toProxy(relPath + (relPath.includes("?") ? "&" : "?") + "t=" + Date.now()));
      if (!res.ok) throw new Error("HTTP " + res.status);
      const blob = await res.blob();
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename || relPath.split("/").pop() || "download";
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(() => URL.revokeObjectURL(a.href), 1500);
    }

    let timer = null;
    async function pollStatus() {
      try {
        const s = await getJSON("status");
        document.getElementById("phase").textContent = "phase: " + s.phase;
        document.getElementById("iter").textContent  = "iter: " + s.iter;
        document.getElementById("fill").style.width = (s.percent || 0) + "%";
        if (s.phase === "done" || s.phase === "error") {
          clearInterval(timer);
          try {
            const res = await getJSON("result");
            document.getElementById("result").textContent = JSON.stringify(res, null, 2);
            document.getElementById("done").innerHTML = (s.phase === "done")
              ? "<b class='ok'>Done!</b>"
              : "<b class='err'>Error. See error.json in run folder.</b>";
          } catch (e) {
            document.getElementById("done").innerHTML = "<b class='err'>Could not read result: " + e.message + "</b>";
          }
        }
      } catch (e) { console.log("poll error:", e); }
    }

    // When you click Start, we collect all inputs and send them to /start.
    document.getElementById("start").onclick = async () => {
      document.getElementById("done").textContent = "";
      document.getElementById("result").textContent = "";
      document.getElementById("fill").style.width = "0%";
      document.getElementById("phase").textContent = "phase: starting...";
      try {
        const rawCount = (document.getElementById("seed_count").value || "").trim();
        const countVal = rawCount === "" ? null : parseInt(rawCount, 10);
        await postJSON("start", {
          seed_source:    document.getElementById("seed_source").value,
          seed_count:     countVal,
          hf_dataset_id:  document.getElementById("hf_id").value,
          temperature:    parseFloat(document.getElementById("temperature").value),
          max_new_tokens: parseInt(document.getElementById("max_new_tokens").value, 10)
        });
        clearInterval(timer);
        timer = setInterval(pollStatus, 800);
      } catch (e) {
        document.getElementById("done").innerHTML = "<b class='err'>Start failed:</b> " + e.message;
      }
    };

    document.getElementById("export").onclick = async () => {
      try {
        let rid=null; try{ rid=(await getJSON("result")).run_id; }catch(_){}
        const d = await postJSON("export_report", rid? {run_id: rid} : {});
        await blobDownload(d.report_path, "report.html");
        document.getElementById("done").innerHTML = "<b class='ok'>Report exported.</b>";
      } catch (e) {
        document.getElementById("done").innerHTML = "Export failed: " + e.message;
      }
    };

    document.getElementById("zip").onclick = async () => {
      try {
        let rid=null; try{ rid=(await getJSON("result")).run_id; }catch(_){}
        const d = await postJSON("zip_run", rid? {run_id: rid} : {});
        await blobDownload(d.zip_path, d.zip_path.split("/").pop());
        document.getElementById("done").innerHTML = "<b class='ok'>Zip ready.</b>";
      } catch (e) {
        document.getElementById("done").innerHTML = "Zip failed: " + e.message;
      }
    };

    document.getElementById("stop").onclick = async () => {
      try {
        const d = await postJSON("shutdown", {});
        document.getElementById("done").textContent = d.msg || "Server stopping...";
      } catch (e) {
        document.getElementById("done").textContent = "Could not stop: " + e.message;
      }
    };
  </script>
</body>
</html>
