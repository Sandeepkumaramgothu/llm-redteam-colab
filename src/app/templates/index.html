<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Day 9 — Fixes: Fresh Report, Item X/Y, Seeds Refresh</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 2rem; }
    a { color: #1a73e8; text-decoration: none; }
    a:hover { text-decoration: underline; }
    button { padding: 0.6rem 1rem; margin-right: 8px; }
    .bar { width: 420px; height: 12px; background: #eee; border-radius: 6px; overflow: hidden; margin: 10px 0; }
    .fill { height: 100%; background: #4a90e2; width: 0%; transition: width 0.2s; }
    .muted { color: #666; font-size: 0.95rem; }
    .ok { color: #0a0; }
    .err { color: #a00; }
    .mono { font-family: ui-monospace, Menlo, Consolas, monospace; white-space: pre-wrap; }
    .box { padding:10px; border:1px solid #eee; border-radius:8px; background:#fafafa; margin: 10px 0; }
    label { margin-right: 10px; }
  </style>
</head>
<body>
  <p><a href="/review">Review latest run →</a></p>
<p><a href="/runs">Run Browser →</a></p>
<p><a href="/dashboard">Metrics Dashboard →</a></p>
<p><a href="/inspect">Inspect & Re-run →</a></p>
<h2>Day 9 — Fixes</h2>
  <!-- Change: "Open latest report" forces a cache-busting query param -->
  <p><a href="#" id="open_report">Open latest report →</a></p>

  <button id="start">Start</button>
  <button id="export">Export Report</button>
  <button id="zip">Zip Run</button>
  <button id="stop">Stop</button>

  <div class="box">
    <h3>Seeds</h3>
    <label>Source:
      <select id="seed_source">
        <option value="local" selected>Local (src/storage/seeds.json or seeds.jsonl)</option>
        <option value="dna">Hugging Face: Do-Not-Answer</option>
      </select>
    </label>
    <label>Count:
      <input id="seed_count" type="number" placeholder="(Local: blank = ALL)" style="width:180px" />
    </label>
    <label>HF dataset id:
      <input id="hf_id" type="text" value="LibrAI/do-not-answer" style="width:260px" />
    </label>
    <div class="muted">We rewrite <code>src/storage/seeds.jsonl</code> for each run with the exact prompts used.</div>
  </div>

  <div class="box">
    <h3>Preferred Model</h3>
    <label>Model:
      <select id="preferred_model" style="width:360px">
        <option value="meta-llama/Llama-2-7b-chat-hf" selected>meta-llama/Llama-2-7b-chat-hf (gated)</option>
        <option value="meta-llama/Llama-3.2-3B-Instruct">meta-llama/Llama-3.2-3B-Instruct (gated)</option>
        <option value="Qwen/Qwen2.5-7B-Instruct">Qwen/Qwen2.5-7B-Instruct (open)</option>
        <option value="microsoft/Phi-3-mini-4k-instruct">microsoft/Phi-3-mini-4k-instruct (open)</option>
        <option value="google/flan-t5-small">google/flan-t5-small</option>
      </select>
    </label>
  </div>

  <div class="box">
    <h3>Generation Controls</h3>
    <label>Temperature:
      <input id="temperature" type="number" step="0.1" min="0" max="1" value="0.7" style="width:80px" />
    </label>
    <label>Max new tokens:
      <input id="max_new_tokens" type="number" min="1" max="512" value="64" style="width:120px" />
    </label>
  </div>

  <div class="bar"><div id="fill" class="fill"></div></div>
  <div id="phase" class="muted">phase: idle</div>
  <!-- Change: we show "item X / Y" using current & total -->
  <div id="progress" class="muted">item: 0 / 0</div>
  <div id="model_info" class="muted"></div>
  <div id="done" class="muted"></div>
  <pre id="result" class="muted mono"></pre>

  <script>
    function toProxy(relPath) {
      if (!relPath) return window.location.href;
      if (relPath.startsWith("/")) relPath = relPath.slice(1);
      return new URL(relPath, window.location.href).href;
    }

    async function getJSON(url) {
      const r = await fetch(toProxy(url));
      const ct = r.headers.get("content-type") || "";
      const txt = await r.text();
      if (!ct.includes("application/json")) throw new Error(`HTTP ${r.status} ${ct} :: ${txt.slice(0,160)}`);
      const data = JSON.parse(txt);
      if (!r.ok || data.ok === false) throw new Error((data && data.error) || `HTTP ${r.status}`);
      return data;
    }

    async function postJSON(url, body) {
      const r = await fetch(toProxy(url), {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body||{})
      });
      const ct = r.headers.get("content-type") || "";
      const txt = await r.text();
      if (!ct.includes("application/json")) throw new Error(`HTTP ${r.status} ${ct} :: ${txt.slice(0,160)}`);
      const data = JSON.parse(txt);
      if (!r.ok || data.ok === false) throw new Error((data && data.error) || `HTTP ${r.status}`);
      return data;
    }

    async function blobDownload(relPath, filename) {
      const res = await fetch(toProxy(relPath + (relPath.includes("?") ? "&" : "?") + "t=" + Date.now()));
      if (!res.ok) throw new Error("HTTP " + res.status);
      const blob = await res.blob();
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename || relPath.split("/").pop() || "download";
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(() => URL.revokeObjectURL(a.href), 1500);
    }

    let timer = null;
    async function pollStatus() {
      try {
        const s = await getJSON("status");
        document.getElementById("phase").textContent = "phase: " + s.phase;
        document.getElementById("fill").style.width = (s.percent || 0) + "%";

        // Show item X / Y using current & total (falls back to iter if needed)
        const cur = (typeof s.current === "number") ? s.current : (s.iter || 0);
        const tot = (typeof s.total === "number") ? s.total : 0;
        document.getElementById("progress").textContent = "item: " + cur + " / " + tot;

        if (s.phase === "done" || s.phase === "error") {
          clearInterval(timer);
          try {
            const res = await getJSON("result");
            document.getElementById("result").textContent = JSON.stringify(res, null, 2);
            const actual = (res && res.actual_model) ? res.actual_model : "(unknown)";
            document.getElementById("model_info").textContent = "Loaded model: " + actual;
            document.getElementById("done").innerHTML = (s.phase === "done")
              ? "<b class='ok'>Done!</b>"
              : "<b class='err'>Error. See error.json in run folder.</b>";
          } catch (e) {
            document.getElementById("done").innerHTML = "<b class='err'>Could not read result: " + e.message + "</b>";
          }
        }
      } catch (e) { console.log("poll error:", e); }
    }

    document.getElementById("start").onclick = async () => {
      document.getElementById("done").textContent = "";
      document.getElementById("result").textContent = "";
      document.getElementById("model_info").textContent = "";
      document.getElementById("fill").style.width = "0%";
      document.getElementById("phase").textContent = "phase: starting...";
      document.getElementById("progress").textContent = "item: 0 / 0";
      try {
        const rawCount = (document.getElementById("seed_count").value || "").trim();
        const countVal = rawCount === "" ? null : parseInt(rawCount, 10);
        const body = {
          seed_source:    document.getElementById("seed_source").value,
          seed_count:     countVal,
          hf_dataset_id:  document.getElementById("hf_id").value,
          temperature:    parseFloat(document.getElementById("temperature").value),
          max_new_tokens: parseInt(document.getElementById("max_new_tokens").value, 10),
          preferred_model:document.getElementById("preferred_model").value
        };
        await postJSON("start", body);
        clearInterval(timer);
        timer = setInterval(pollStatus, 800);
      } catch (e) {
        document.getElementById("done").innerHTML = "<b class='err'>Start failed:</b> " + e.message;
      }
    };

    document.getElementById("export").onclick = async () => {
      try {
        let rid=null; try{ rid=(await getJSON("result")).run_id; }catch(_){}
        const d = await postJSON("export_report", rid? {run_id: rid} : {});
        await blobDownload(d.report_path, "report.html");
        document.getElementById("done").innerHTML = "<b class='ok'>Report exported.</b>";
      } catch (e) {
        document.getElementById("done").innerHTML = "Export failed: " + e.message;
      }
    };

    document.getElementById("zip").onclick = async () => {
      try {
        let rid=null; try{ rid=(await getJSON("result")).run_id; }catch(_){}
        const d = await postJSON("zip_run", rid? {run_id: rid} : {});
        await blobDownload(d.zip_path, d.zip_path.split("/").pop());
        document.getElementById("done").innerHTML = "<b class='ok'>Zip ready.</b>";
      } catch (e) {
        document.getElementById("done").innerHTML = "Zip failed: " + e.message;
      }
    };

    document.getElementById("stop").onclick = async () => {
      try {
        const d = await postJSON("shutdown", {});
        document.getElementById("done").textContent = d.msg || "Server stopping...";
      } catch (e) {
        document.getElementById("done").textContent = "Could not stop: " + e.message;
      }
    };

    // Force the report to load freshly (no cache) by appending ?t=timestamp
    document.getElementById("open_report").onclick = (e) => {
      e.preventDefault();
      window.location.href = toProxy("report?t=" + Date.now());
    };
  </script>
</body>
</html>
